extensions [matrix nw]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; --- New local variables for students ---
  ; Bus variables
  capacity
  selected-stop
  state
  vote
  unread
  prev-inbox-length
  all-bus-stops
  
  ; Variables for coordination
  expected-replies
  received-replies
  expected-votes
  received-votes
  destination-replies
  passenger-count-replies
  
  ; Variables for competition
  reward_points
  
  ; Variables for shrtest path
  strategy
  shortest_path
  
  ; Communication protocol
  ask-destination
  report-destination
  ask-passenger-count
  report-passenger-count
  
  ; State variables
  state-new-bus
  state-choose-stop
  state-ask-destinations
  state-wait-responses
  state-pickup
  state-move
  state-drop
  state-inactive
  
  ; Voting scheme variables
  vote-add-bus
  vote-wait-response
  vote-no-vote
]
 
globals [
  graph
]

to init-buses
  ; Initialize your agents here.
  ; Bus capacities
   ; Use different predefined paths for each bus type
  if bus_type = 1
  [
    set capacity bus_type1_capacity
  ]
  if bus_type = 2
  [
    set capacity bus_type2_capacity
  ]
  if bus_type = 3
  [
    set capacity bus_type3_capacity
  ]
  
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  
  set all-bus-stops reverse n-values length amsterdam_bus_stops_names [23 - ?]

  set selected-stop -1
  ; Initialize communication protocol
  set ask-destination "ask-destination"
  set report-destination "report-destination"
  set ask-passenger-count "ask-passenger-count"
  set report-passenger-count "report-passenger-count"
  
  set reward_points 0
  set strategy "random"
  set shortest_path []
  
  ; Initialize state strings
  set state-new-bus "state-new-bus"
  set state-choose-stop "state-choose-stop"
  set state-ask-destinations "state-ask-destinations"
  set state-wait-responses "state-wait-responses"
  set state-pickup "state-pickup"
  set state-move "state-move"
  set state-drop "state-drop"
  set state-inactive "state-inactive"
  
  ; Initialize voting scheme strings
  set vote-add-bus "vote-add-bus"
  set vote-wait-response "vote-wait-response"
  set vote-no-vote "no-vote"
  
  ; Initial state
  set state state-new-bus
  ; Initial voting scheme
  set vote vote-no-vote
  
  ; Initialize unread messages
  set unread []
  set prev-inbox-length 0
  set expected-replies 0
  set received-replies 0
  set expected-votes 0
  set received-votes 0
  set destination-replies []
  set passenger-count-replies []
end

to execute-actions
  ; If bus is new in the system, send it to bus stop with maximum amount of passengers waiting
  if state = state-new-bus[
    init-operating
    set state state-move
  ]

  ; Next-stop strategy 1: attempt to choose stop based on current passengers
  if state = state-choose-stop [
    ifelse strategy = "random" and (length bus_passengers) < (0.75 * capacity) [
      choose-next-stop-by-passengers
      ; If a choice was made, start picking up passengers, otherwise choose with strategy 2
      if selected-stop = -1 [
        ; ifelse length bus_passengers > 1 [
        ifelse (length bus_passengers) > (0.5 * capacity) [
          set strategy "shortest_path"
          choose-next-stop-by-shortest-path
        ]
        [ init-operating ]
      ]
      set state state-pickup
    ]
    [
      if strategy = "random" [ set strategy "shortest_path" ]
      choose-next-stop-by-shortest-path
      set state state-pickup
      ;choose-next-stop-by-passengers
      ; If a choice was made, start picking up passengers, otherwise choose with strategy 2
      ;ifelse selected-stop = -1 [set state state-ask-destinations][set state state-pickup]
    ]
  ]
  
  ; Next-stop strategy 2: choose adjacent stop with maximum passengers waiting
  ; that has not already been chosen by other buses (what if all have been chosen?) <--------
  ; Step 1: Ask other buses for their destinations
  if state = state-ask-destinations [
    ask-destinations
    set state state-wait-responses
  ]
  ; Step 2: Wait for their replies  
  if state = state-wait-responses [
    ; Step 3: When all buses reply, choose stop and change to state-pickup
    if expected-replies = received-replies [
      choose-next-stop-by-nearby
      set state state-pickup
    ]
  ]
  
  ; Once a stop has been chosen, pick up passengers
  if state = state-pickup [
    ifelse strategy = "random" [ pickup-passengers-random ]
    [ pickup-passengers-shortest-path ]
    set state state-move
  ]
  
  ; Keep moving bus until it arrives to destination
  if state = state-move [
    ifelse current_stop = selected-stop [
      ; When the bus arrives, reset selected-stop and change to state-drop
      set selected-stop -1
      set state state-drop
    ][travel-to selected-stop]
  ]
  
  ; At destination, drop off passengers and change to state-choose-stop
  if state = state-drop [
    drop-passengers
  
    ifelse deactivate_bus [ set state state-inactive ]
    [ set state state-choose-stop ]
  ]
  
  ; Add busses if needed
  if bus_id = 24 [
    let add-new-bus vote_for_new_bus
    if not (add-new-bus = -1) [ add-bus add-new-bus ]
  ]
  
  update-unread
  reply-unread
  
  if state = state-inactive [
    if (length bus_passengers > 0) [
      ifelse selected-stop = -1 [
        choose-next-stop-by-shortest-path
        travel-to selected-stop
      ]
      [
        ifelse current_stop = selected-stop 
        [
          drop-passengers
          if (length bus_passengers > 0) [
            choose-next-stop-by-shortest-path
            travel-to selected-stop
          ]
        ]
        [ travel-to selected-stop ]
      ]
    ]
    
    if activate_bus [
      ifelse current_stop = -1 [set state state-move]
      [ set state state-choose-stop ]
    ]
  ]
end


to init-operating
  ; Get list of all bus stops except the current bus stop
  let other-bus-stops remove current_stop all-bus-stops
  
  ; Smoothed list of passengers waiting
  let stops-weights map [(length ?) + 1] map get-passengers-at-stop other-bus-stops
  ; Cumulative sum
  let cum-sum butfirst reduce [lput (?2 + last ?1) ?1] fput [0] stops-weights
  ; Choose index from uniform distribution
  let choice-value random-float max cum-sum
  ; Get corresponding stop
  let selection-results map [? > choice-value] cum-sum
  let selected-destination item (position true selection-results) other-bus-stops
  
  ifelse (member? selected-destination item current_stop graph) [set selected-stop selected-destination set strategy "random"]
  [
  ; Set shortest paths to that stop
  set strategy "shortest_path"
  set shortest_path get-shortest-path current_stop selected-destination    
  set selected-stop (item 1 shortest_path)
  ]
end

to-report deactivate_bus
  if (amount_passengers_waiting / (count buses)) < 10
  [
    let score 0
    let all_scores []
    ask buses [set all_scores lput (reward_points / capacity) all_scores]
    set score (reward_points / capacity)
    if score = min(all_scores) [ report true ]
  ]
  report false
end

to-report activate_bus
  if (amount_passengers_waiting / (count buses with [not (state = state-inactive)])) > 10
  [
    report true
  ]
  report false
end


; Choose the next stop based on the current passengers
; If there are no passengers or
; if no passenger is going to an adjacent stop
; no choice can be made with strategy 1 so don't modify selected-stop
to choose-next-stop-by-passengers
  if length bus_passengers > 0 [
    ; Get adjacent bus stops 
    let adjacent-stops  item current_stop graph
    ; Initialize with 0 number of passengers going to those stops
    let destination-counts n-values (length adjacent-stops) [0]
    ; Check the destination of each passenger
    foreach bus_passengers [
      ; If going to any of the adjacent stops
      if member? (item 1 ?) adjacent-stops [
        ; Find index in adjacent-stops list
        let stop-idx position (item 1 ?) adjacent-stops
        ; Get current count and increment by one
        let stop-count item stop-idx destination-counts
        set destination-counts replace-item stop-idx destination-counts (stop-count + 1)
      ]
      ; Check if there is at least one passenger going to adjacent stop
      if sum destination-counts > 0 [
        ; Choose stop by majority
        set selected-stop item (position (max destination-counts) destination-counts) adjacent-stops
      ]
    ]
  ]
end

to choose-next-stop-by-shortest-path
  ifelse length shortest_path = 0 [
    let current_passengers matrix:from-column-list bus_passengers
    let destinations modes (matrix:get-row current_passengers 1)
    let destination item 0 destinations
    if (random-float 1) > 0.5 [ set destination item 1 item 0 bus_passengers ]
    set shortest_path get-shortest-path current_stop destination
    set selected-stop (item 1 shortest_path)
  ]
  [
 ifelse member? current_stop shortest_path 
    [
     let next_index ((position current_stop shortest_path) + 1) 
    ifelse (next_index < length shortest_path)[
    set selected-stop item next_index shortest_path
    ] 
      [
      set strategy "random"
      set shortest_path []
    ]
      ]
    [
       set strategy "random"
      set shortest_path []      
      ]
  
  ]
  
  if (position selected-stop shortest_path) = (length shortest_path - 1) [
    set strategy "random"
    set shortest_path []
  ]
end

; Send messages to other buses
; asking for their destinations
to ask-destinations
  let other-buses [bus_id] of other buses
  foreach other-buses [
    send-message ? ask-destination
  ]
  ; Prepare variables to receive replies
  set expected-replies length other-buses
  set received-replies 0
  set destination-replies []
end

to ask-passenger-counts
  let other-buses [bus_id] of other buses
  foreach other-buses [
    send-message ? ask-passenger-count
  ]
  ; Prepare variables to receive replies
  set expected-votes length other-buses
  set received-votes 0
  set passenger-count-replies []
end

to choose-next-stop-by-nearby  
  ; Get adjacent bus stops and sort by number of passengers waiting
  let sorted-adjacent-stops sort-by [length get-passengers-at-stop ?1 > length get-passengers-at-stop ?2] (item current_stop graph)
  ; Remove stops to which other buses are going
  let options []  
  foreach sorted-adjacent-stops [
    if not member? ? destination-replies [
      set options lput ? options
    ]
  ]
  ; If there are no options,
  ; choose the one with the most number of passengers and return
  if length options = 0 [
    ;set selected-stop item 0 sorted-adjacent-stops
    ;stop
    set options sorted-adjacent-stops
  ]
    ; Otherwise select randomly with probability proportional to number of passengers
    ; Smoothed list of passengers waiting
    let stops-weights map [(length ?) + 1] map get-passengers-at-stop options
    ; Cumulative sum
    let cum-sum butfirst reduce [lput (?2 + last ?1) ?1] fput [0] stops-weights
    ; Choose index from uniform distribution
    let choice-value random-float max cum-sum
    ; Get corresponding stop
    let selection-results map [? > choice-value] cum-sum
    set selected-stop item (position true selection-results) options
    
    ;show options
    ;show stops-weights
    ;show cum-sum
    ;show choice-value
    ;show selection-results
    ;show selected-stop
  
end

to drop-passengers
  ; For every passenger currently in the bus
  foreach bus_passengers
  [
   ; Drop the passenger if his/her destination is current bus stop
   if (item 1 ?) = current_stop [
     drop-off-passenger (item 0 ?)
     set reward_points (reward_points + 1)
    ]
  ]
end

to pickup-passengers-shortest-path
  ; Priority 1: Passengers with destination in shortest path
  if not (length shortest_path = 0) [
    foreach (get-passengers-at-stop current_stop)[
      ; If the bus capacity is full don't pickup the passengers 
      if not ((length bus_passengers) < capacity) [ stop ]
      
      ; Pick up the passengers waiting in the current bus stop whose destination matches with passengers inside the bus
      if (member? (item 1 ?) shortest_path)[
        pick-up-passenger (item 0 ?)
      ]
    ]
  ]
  
  
  ; Priority 2: passengers with destination same as passengers inside
  ; Get list of destinations of passengers inside the bus
  let destinations []
  foreach bus_passengers [ set destinations lput (item 1 ?) destinations ]
  set destinations remove-duplicates destinations
  
  if not (length destinations = 0) [
    foreach (get-passengers-at-stop current_stop)[
      ; If the bus capacity is full don't pickup the passengers 
      if not ((length bus_passengers) < capacity) [ stop ]
      
      ; Pick up the passengers waiting in the current bus stop whose destination matches with passengers inside the bus
      if (member? (item 1 ?) destinations)[
        pick-up-passenger (item 0 ?)
      ]
    ]
  ]
end

to pickup-passengers-random
  ; Pick up the passengers waiting at the current bus stop
  
  ; Get list of destinations of passengers inside the bus
  let destinations []
  foreach bus_passengers [ set destinations lput (item 1 ?) destinations ]
  set destinations remove-duplicates destinations
  
  ; Priority 1 : Passengers inside the bus
  if not (length destinations = 0) [
    foreach (get-passengers-at-stop current_stop)[
      ; If the bus capacity is full don't pickup the passengers 
      if not ((length bus_passengers) < capacity) [ stop ]
      
      ; Pick up the passengers waiting in the current bus stop whose destination matches with passengers inside the bus
      if (member? (item 1 ?) destinations)[
        pick-up-passenger (item 0 ?)
      ]
    ]
  ]
  
  ; Priority 2 : Passengers at the current bus stop
  foreach (get-passengers-at-stop current_stop)
  [
    ; If the bus capacity is full don't pickup the passengers 
    if not ((length bus_passengers) < capacity) [ stop ]
    
    ; Pick up the passengers waiting in the current bus stop whose destination is the next stop of the bus
    if ((item 1 ?) = selected-stop)
    [
      pick-up-passenger (item 0 ?)
    ]
  ]
  
  ; Priority 3
  if length (get-passengers-at-stop current_stop) = 0 [stop]
  let current_passengers matrix:from-column-list (get-passengers-at-stop current_stop)
  let top_destinations modes (matrix:get-row current_passengers 1)
  let destination item 0 top_destinations
  
  foreach (get-passengers-at-stop current_stop)
  [
    ; If the bus capacity is full don't pickup the passengers 
    if not ((length bus_passengers) < capacity) [ stop ]
    
    if ((item 1 ?) = destination) [ pick-up-passenger (item 0 ?) ]
  ]
end

; Check if the size of the inbox has changed.
; If so, update the unread list.
to update-unread
  ; Compare current length of inbox to its
  ; length in the previous tick
  if length inbox > prev-inbox-length [
    ; If length increased, add new messages to the unread list
    let i prev-inbox-length
    while [i < length inbox] [
      set unread lput (item i inbox) unread
      set i (i + 1)
    ]
    ; Update length of inbox in previous tick
    set prev-inbox-length length inbox
  ]
end

; Check the unread list for messages that 
; need a reply. After replying, remove them
; from unread list. Messages that are not
; answered are left intact in unread.
to reply-unread
  let not-replied []
  foreach unread [
    let message item 2 ?
    let sender item 1 ?
    let replied "No"
    
    if message = ask-destination [
      ; Reply to messages asking for destination
      send-message sender (word report-destination next_stop)
      set replied "Yes"
    ]
    if message = ask-passenger-count [
      ; Reply to messages asking for passenger count inside the bus
      let add-bus-fact 0
      if not (current_stop = -1) and (length get-passengers-at-stop current_stop) > 0[
        set add-bus-fact (amount_passengers_waiting / (length get-passengers-at-stop current_stop))
      ]
      set add-bus-fact (add-bus-fact + (length bus_passengers / capacity))
      set add-bus-fact (add-bus-fact / 2)
      
      let new-bus 1
      if add-bus-fact > 0.15 [ set new-bus 2 ]
      if add-bus-fact > 0.45 [ set new-bus 3 ]
      
      send-message sender (word report-passenger-count new-bus)
      set replied "Yes"
    ]
    if not (message = ask-destination) and not (message = ask-passenger-count) [
    ifelse (substring message 0 (length report-destination)) = report-destination [
      let reported-destination read-from-string (substring message (length report-destination) (length message))
      set destination-replies lput reported-destination destination-replies
      set received-replies (received-replies + 1)
      set replied "Yes"
    ]
    ;if (substring message 0 (length report-passenger-count)) = report-passenger-count [
    [
      let reported-passenger-count read-from-string (substring message (length report-passenger-count) (length message))
      set passenger-count-replies lput reported-passenger-count passenger-count-replies
      set received-votes (received-votes + 1)
      set replied "Yes"
    ]]
    if replied = "No" [
      set not-replied lput ? not-replied
    ]
  ]
  set unread not-replied
end

to-report vote_for_new_bus
  if (count buses) = 1 [report 2]
  if (count buses) = 2 [report 3]

  if vote = vote-no-vote [     
    let ppb 50
    if (count buses) > 10 [set ppb 150]
    if (amount_passengers_waiting / (count buses)) > ppb [ set vote vote-add-bus ]
  ]
  
  if vote = vote-add-bus [
    ask-passenger-counts
    set vote vote-wait-response
  ]
  if vote = vote-wait-response [
    if expected-votes = received-votes [
      let new-bus (item 0 modes passenger-count-replies)
      set passenger-count-replies []
      set vote vote-no-vote
      report new-bus
    ]
  ]
  report -1
  
end

to-report get-shortest-path [source destination]
  let path []
  ask bus_stop source [ set path (nw:path-to bus_stop destination) ]
  let shortest_route []
  set shortest_route lput source shortest_route
  
  let current_source source
  let stops []
  foreach path [
    ask ? [ ask both-ends [ set stops lput who stops ] ]
    foreach stops [
      if not (member? ? shortest_route) [ set shortest_route lput ? shortest_route ]
    ]
    set stops []
  ]
  
  report shortest_route
end