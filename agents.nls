buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; --- New local variables for students ---
  ; Bus variables
  capacity
  selected-stop
  state
  unread
  prev-inbox-length
  
  ; Communication protocol
  ask-destination
  report-destination
  
  ; State variables
  state-choose-stop
  state-ask-destinations
  state-wait-responses
  state-pickup
  state-move
  state-drop
]
 
globals [
  graph
]

to init-buses
  ; Initialize your agents here.
  ; Bus capacities
   ; Use different predefined paths for each bus type
  if bus_type = 1
  [
    set capacity bus_type1_capacity
  ]
  if bus_type = 2
  [
    set capacity bus_type2_capacity
  ]
  if bus_type = 3
  [
    set capacity bus_type3_capacity
  ]
  
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  
  set selected-stop -1
  ; Initialize communication protocol
  set ask-destination "Where are you going?"
  set report-destination "I'm going to "
  
  ; Initialize state strings
  set state-choose-stop "state-choose-stop"
  set state-ask-destinations "state-ask-destinations"
  set state-wait-responses "state-wait-responses"
  set state-pickup "state-pickup"
  set state-move "state-move"
  set state-drop "state-drop"
  ; Initial state
  set state state-choose-stop
  ; Initialize unread messages
  set unread []
  set prev-inbox-length 0
end

to execute-actions
  ; Next-stop strategy 1: attempt to choose stop based on current passengers
  if state = state-choose-stop [    
    choose-next-stop-by-passengers
    ; If a choice was made, start picking up passengers, otherwise choose with strategy 2
    ifelse selected-stop = -1 [set state state-ask-destinations][set state state-pickup]
  ]
  
  ; Next-stop strategy 2: choose adjacent stop with maximum passengers waiting
  ; that has not already been chosen by other buses (what if all have been chosen?) <--------
  ; Step 1: Ask other buses for their destinations
  if state = state-ask-destinations [
    ask-destinations
    set state state-wait-responses
  ]
  ; Step 2: Wait for their replies  
  if state = state-wait-responses [
    ; Step 3: When all buses reply, choose stop and change to state-pickup
    if all-replied [
      choose-next-stop-by-nearby
      set state state-pickup
    ]
  ]
  
  ; Once a stop has been chosen, pick up passengers
  if state = state-pickup [
    pickup-passengers
    set state state-move
  ]
  
  ; Keep moving until you get there!
  if state = state-move [
    ifelse current_stop = selected-stop [
      ; When the bus arrives, reset selected-stop and change to state-choose-stop
      set selected-stop -1
      set state state-choose-stop
    ][travel-to selected-stop]
  ]
  
  update-unread
  reply-unread
end

to choose-next-stop-by-passengers
  ; Choose the next stop based on the current passengers
  ; If there are no passengers or
  ; if no passenger is going to an adjacent stop
  ; no choice can be made with strategy 1 so don't modify selected-stop
  
  if length bus_passengers > 0 [
    ; Get adjacent bus stops 
    let adjacent-stops  item current_stop graph
    ; Initialize with 0 number of passengers going to those stops
    let destination-counts n-values (length adjacent-stops) [0]
    ; Check the destination of each passenger
    foreach bus_passengers [
      ; If going to any of the adjacent stops
      if member? (item 1 ?) adjacent-stops [
        ; Find index in adjacent-stops list
        let stop-idx position (item 1 ?) adjacent-stops
        ; Get current count and increment by one
        let stop-count item stop-idx destination-counts
        set destination-counts replace-item stop-idx destination-counts (stop-count + 1)
      ]
      ; Check if there is at least one passenger going to adjacent stop
      if sum destination-counts > 0 [
        ; Choose stop by majority
        set selected-stop item (position (max destination-counts) destination-counts) adjacent-stops
      ]
    ]
  ]
end

to ask-destinations
  let other_buses [bus_id] of other buses
  foreach other_buses [
    send-message ? ask-destination
  ]
end

to-report all-replied
  ; Report true if the number of messages in inbox replying to
  ; the previously sent "ask-destination" message
  ; is equal to (number of buses - 1)
  ; Otherwise report false
  ; TODO
  report false
end

to choose-next-stop-by-nearby  
  ; Get adjacent bus stops 
  let adjacent_stops  item current_stop graph
  
  ; filter out stops to which other buses are going
  ; If all stops are filtered out, choose the one with
  ; maximum number of passengers waiting
  ; TODO
  
  ; Get amount of passengers waiting at adjacent stops  
  let nr_waiting_pass map length map get-passengers-at-stop adjacent_stops

  ; Get index of bus stop with maximum passengers and set it as next destination
  set selected-stop item position max nr_waiting_pass nr_waiting_pass adjacent_stops
end

to drop_passengers
  ; For every passenger currently in the bus
  foreach bus_passengers
  [
   ; Drop the passenger if his/her destination is current bus stop
   if (item 1 ?) = current_stop [
     drop-off-passenger (item 0 ?)
    ]
  ]
end

to pickup-passengers  
   ; Pick up the passengers waiting in the current bus stop
  foreach (get-passengers-at-stop current_stop)[
    ; If the bus capacity is full don't pickup the passengers 
    if not ((length bus_passengers) < capacity) [ stop ]
    
    ; Pick up the passengers waiting at the current bus stop  
    pick-up-passenger (item 0 ?)
  ]
end

to update-unread
  if length inbox > prev-inbox-length [
    let i prev-inbox-length
    while [i < length inbox] [
      set unread lput (item i inbox) unread
      set i (i + 1)
    ]
    set prev-inbox-length length inbox
  ]
end

to reply-unread
  let not-replied []
  foreach unread [
    let performative item 2 ?
    let sender item 1 ?
    ifelse performative = ask-destination [
      send-message sender (word report-destination next_stop)
    ][
      set not-replied lput ? not-replied
    ]
  ]
  set unread not-replied
end
