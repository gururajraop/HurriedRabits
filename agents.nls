buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  passengers_list
  neighbour
  path
  path_position
  different_route_passenger_list
]
 
globals [
  graph
]

to init-buses
  ; Initialize your agents here.
  
  ; Use different predefined paths for each bus type
  if bus_type = 1
  [
    set path [3 9 8 2 8 6 8 9]
  ]
  if bus_type = 2
  [
    set path [3 4 5 10 17 7 13 22 21 20]
  ]
  if bus_type = 3
  [
    set path [3 16 11 1 19 23 14 0 15 18 15 12 20 9]
  ]
  
  ; Set initial position to be central ie bus stop id 3 which is the 0th element in path
  set path_position 0
  
  ; Create an empty list of passengers who have destination other than stops in the current buses path
  set different_route_passenger_list []

  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  ; show (word "previous stop:" previous_stop ", Current stop:" current_stop ", Next stop:" next_stop)
  
  ifelse current_stop = -1
  [
    travel-to next_stop
  ]
  [
    ; drop the passengers at the current stop
    drop_passengers
    
    ; Select the next stop
    choose_next_stop

    ; pickup the passengers at the current stop
    pickup_passengers
    
    ;travel to the next bus stop
    travel-to next_stop
  ]
end

to drop_passengers
  ; For every passenger currently in the bus
  foreach bus_passengers
  [
   ; Drop the passenger if his/her destination is current bus stop
   if (item 1 ?) = current_stop [
     drop-off-passenger (item 0 ?)
    ]
  ]
  
  ; Drop the passengers in central who have destination in different route
  ; so that they can pickup the appropriate bus of that route 
  if current_stop = 3
  [
    foreach different_route_passenger_list
    [
      drop-off-passenger ?
    ]
  ]
end

to pickup_passengers
  ; Pick up the passengers waiting in the current bus stop
  foreach (get-passengers-at-stop current_stop)
  [
    ; If the passenger has destination in the bus travel path, pick them up
    ifelse (member? (item 1 ?) path) [
      pick-up-passenger (item 0 ?)
    ]
    [
      ; Otherwise, pickup the passenger and drop them at central station (bus stop 3)
      ; so that they can pick up bus that goes to their destination
      if not (current_stop = 3)
      [
        pick-up-passenger (item 0 ?)
        set different_route_passenger_list lput (item 0 ?) different_route_passenger_list
      ]
    ]
  ]
end


to choose_next_stop
  ifelse path_position < ((length path) - 1) 
  [ 
    ; Set next stop based on the predefined fixed path
    set path_position (path_position + 1) 
  ]
  [
    ; loop back to the starting of the path
    set path_position 0
  ]
  set next_stop (item path_position path)
end